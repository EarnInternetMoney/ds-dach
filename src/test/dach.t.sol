/// dach.t.sol -- test for dach.sol

// Copyright (C) 2019  Martin Lundfall

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity >=0.4.23;

import "ds-test/test.sol";
import {Vat} from 'dss/vat.sol';
import {Pot} from 'dss/pot.sol';
import {Dai} from 'dss/dai.sol';
import {DaiJoin} from 'dss/join.sol';
import "../dach.sol";
import {ChaiSetup, UniswapSetup} from "./uniswap.t.sol";

contract FactoryLike {
  function initializeFactory(address) public {}
  function createExchange(address) public returns (address) {}
}

contract FrontRunner {
  Dach dach;
  constructor(Dach _dach) public {
    dach = Dach(_dach);
  }

  function frontRun(address sender, address receiver, uint amount, uint fee, uint nonce,
                    uint expiry, uint8 v, bytes32 r, bytes32 s, address relayer) public {
    dach.clear(sender,receiver,amount,fee,nonce,expiry,v,r,s,relayer);
  }
}

contract Hevm {
    function warp(uint256) public;
}


contract DachTest is DSTest, ChaiSetup, UniswapSetup {

    Hevm hevm;
    FrontRunner frontRunner;
    uint preBalance;
    uint constant initialBalance = 100;

    //    Dai dai;
    //    Chai chai;
    Dach dach;
    uint constant chainId = 99;

    address payable ali = 0xc3455912Cf4bF115835A655c70bCeFC9cF4568eB; //I am the greatest, I said that even before I knew I was.
    address cal = 0x29C76e6aD8f28BB1004902578Fb108c507Be341b;
    address del = 0xdd2d5D3f7f1b35b7A0601D6A00DbB7D44Af58479; //the funky homosapien
    address acab = address(0xacab);


    function setUp() public {
      super.setUp();
      hevm = Hevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
      dach = new Dach(address(dai), address(uniswapdai), address(chai), 99);
      frontRunner = new FrontRunner(dach);
      permit_dach();
      dai.transfer(ali, 100);             
      preBalance = 100 ether - 140;
      assertEq(dai.balanceOf(ali), 100);
      assertEq(dai.balanceOf(address(this)), preBalance);
      assertEq(ali.balance, 0);
      assertEq(dach.nonces(ali),0);
    }
    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }
    function rmul(uint x, uint y) internal pure returns (uint z) {
        // always rounds down
        z = mul(x, y) / RAY;
    }
    function rdiv(uint x, uint y) internal pure returns (uint z) {
        // always rounds down
        z = mul(x, RAY) / y;
    }
    uint constant RAY = 10 ** 27;

    function test_basic_sanity() public {
      assertTrue(true);
    }

    function test_dai_address() public {
        //The dai address generated by hevm
        //used for signature generation testing
        assertEq(address(dai), address(0x959DC1D68ba3a9f6959239135bcbc854b781eb9a));
        assertEq(address(dai), address(dach.dai()));
    }

    function test_dach_address() public {
        //The dai address generated by hevm
        //used for signature generation testing
        assertEq(address(dach), address(0xDa54dfB70A3a4d4fBc8865Bef49665934f789396));
    }


    function test_this_address() public {
      assertEq(address(this), address(0x47f5b4DDAFD69A6271f3E15518076e0305a2C722));
    }

    function test_domain_separator() public {

      assertEq(dai.DOMAIN_SEPARATOR(), 0x004fc4b4f32cff7fc90e2552f91a943df3d61e2b9ce17a4664c77b2c5177ec1f);
    }

    function permit_dach() public {
      bytes32 r = 0x48db45248db4cb5df659edc6d653389eb556c33a2de6a93f100632c201ab7870;
      bytes32 s = 0x2293b374b1565c9887dda38204b8f498388842620d355eb3c78a9bd18e72efe1;
      uint8 v = 27;
      dai.permit(ali, address(dach), 0, 0, true, v, r, s);
    }

    function test_cheque() public {
      bytes32 r = 0xcd72cd18daed29617ff6c85af4887530ec54eb1eb41b5cc39912bfa78c9ce9e7;
      bytes32 s = 0x4af4a80dd4c1b3b5096f3ab66050eb7b7d7e1b41508dabd1f37e02a8872d78fc;
      uint8 v = 27;
      dach.clear(ali, del, 10, 1, 0, 0, v, r, s, address(this));
      assertEq(dach.nonces(ali),1);
      assertEq(dai.balanceOf(ali), 89);
      assertEq(dai.balanceOf(del), 10);
      assertEq(dai.balanceOf(address(this)), preBalance + 1);
    }

    function testFail_cheque_frontrun() public {
      bytes32 r = 0xcd72cd18daed29617ff6c85af4887530ec54eb1eb41b5cc39912bfa78c9ce9e7;
      bytes32 s = 0x4af4a80dd4c1b3b5096f3ab66050eb7b7d7e1b41508dabd1f37e02a8872d78fc;
      uint8 v = 27;
      frontRunner.frontRun(ali, del, 10, 1, 0, 0, v, r, s, address(this));
    }

    function test_swap() public {
      bytes32 r = 0x3309811fb2251bdd213b2d9a4d0a508ed738a5c711b7070d26212d5339255d80;
      bytes32 s = 0x3b89f27b65f3ecb9bcbea56edc9d8e82b4b9a0e2a5b9127e2c33922cd1a17a83;
      uint8 v = 28;
      dach.swapToEth(ali, 10, 332665999, 1, 0, 0, v, r, s, address(this));
      assertEq(dach.nonces(ali),1);
      assertEq(dai.balanceOf(ali), 89);
      assertEq(ali.balance, 332665999);
      assertEq(dai.balanceOf(address(this)), preBalance + 1);
    }

    function test_join() public {
      bytes32 r = 0xad36f2f7c0017c6afa5b3b8977cc9a76fc6afc9dccbeb8cf916baff48923a27a;
      bytes32 s = 0x4ae8bc565d188e9b31ea59c0ffbe2822910aaebc0f830d32177490c82d07e070;
      uint8 v = 28;
      dach.joinChai(ali, ali, 50, 1, 0, 0, v, r, s, address(this));
      assertEq(chai.dai(ali), 50);
      assertEq(chai.balanceOf(ali), rmul(50, pot.chi()));
      assertEq(dai.balanceOf(address(this)), preBalance + 1);
      assertEq(dai.balanceOf(ali), 49);
    }

    function test_chai_permit_dach() public {
      bytes32 r = 0x72e45f6b52efcdfceb115a90b9856bdc74d99dee4789c54c1b48f6e8f81cc79e;
      bytes32 s = 0x685de41a08e90cb482b497cf4b2657ea99f4a11f4e52b2b98c458a2b985b1f9c;
      uint8 v = 27;
      assertEq(chai.nonces(ali), 0);
      assertEq(chai.allowance(ali, del), 0);
      chai.permit(ali, address(dach), 0, 0, true, v, r, s);
      assertEq(chai.allowance(ali, address(dach)),uint(-1));
      assertEq(chai.nonces(ali),1);
    }


    function test_exit() public {
      pot.file("dsr", uint(1000000564701133626865910626));  // 5% / day
      test_join();
      test_chai_permit_dach();
      assertEq(chai.dai(ali), 50);
      hevm.warp(now + 1 days);
      assertEq(chai.dai(ali), 52);
      bytes32 r = 0x3969b18fbfa5e3a88e684b74d4915945dbd994f45638dd34ec80ccd41d172863;
      bytes32 s = 0x69f3d1fec1c3d3b055c9519db14e35341adbbb05bfb3b8cd95935eeb49117376;
      uint8 v = 28;
      dach.drawChai(ali, ali, 50, 1, 1, 0, v, r, s, address(this));
      //An extra wei dai was given since chai.draw rounds up
      assertEq(chai.dai(ali), 1);
      assertEq(dai.balanceOf(ali), 99);
      assertEq(dai.balanceOf(address(this)), preBalance + 2);
    }

}
